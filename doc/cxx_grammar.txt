
@primary_expression:
	@literal
	this
	( @expression )
	@id_expression
	@lambda_expression

@id_expression:
	@unqualified_id
	@qualified_id

@unqualified_id:
	@identifier
	@operator_function_id
	@conversion_function_id
	@literal_operator_id
	~ @class_name
	~ @decltype_specifier
	@template_id

@qualified_id:
	@nested_name_specifier @template_opt @unqualified_id

@nested_name_specifier:
	::
	@type_name ::
	@namespace_name ::
	@decltype_specifier ::
	@nested_name_specifier @identifier ::
	@nested_name_specifier @template_opt @simple_template_id ::

@lambda_expression:
	@lambda_introducer @lambda_declarator_opt @compound_statement

@lambda_introducer:
	[ @lambda_capture_opt ]

@lambda_capture:
	@capture_default
	@capture_list
	@capture_default , @capture_list

@capture_default:
	&
	=

@capture_list:
	@capture ..._opt
	@capture_list , @capture ..._opt

@capture:
	@simple_capture
	@init_capture

@simple_capture:
	@identifier
	& @identifier
	this

@init_capture:
	@identifier @initializer
	& @identifier @initializer

@lambda_declarator:
	( @parameter_declaration_clause ) mutable_opt
	@exception_specification_opt @attribute_specifier_seq_opt @trailing_return_type_opt

@postfix_expression:
	@primary_expression
	@postfix_expression [ @expression ]
	@postfix_expression [ @braced_init_list ]
	@postfix_expression ( @expression_listopt )
	@simple_type_specifier ( @expression_listopt )
	@typename_specifier ( @expression_listopt )
	@simple_type_specifier @braced_init_list
	@typename_specifier @braced_init_list
	@postfix_expression . templateopt @id_expression
	@postfix_expression -> templateopt @id_expression
	@postfix_expression . @pseudo_destructor_name
	@postfix_expression -> @pseudo_destructor_name
	@postfix_expression ++
	@postfix_expression --
	dynamic_cast < @type_id > ( @expression )
	static_cast < @type_id > ( @expression )
	reinterpret_cast < @type_id > ( @expression )
	const_cast < @type_id > ( @expression )
	typeid ( @expression )
	typeid ( @type_id )

expression-list:
	initializer-list

pseudo-destructor-name:
	nested-name-specifieropt type-name :: ~ type-name
	nested-name-specifier template simple-template-id :: ~ type-name
	nested-name-specifieropt ~ type-name
	~ decltype-specifier

unary-expression:
	postfix-expression
	++ cast-expression
	-- cast-expression
	unary-operator cast-expression
	sizeof unary-expression
	sizeof ( type-id )
	sizeof ... ( identifier )
	alignof ( type-id )
	noexcept-expression
	new-expression
	delete-expression

unary-operator:
	*
	& 
	+ 
	- 
	! 
	~

new-expression:
	::opt new new-placementopt new-type-id new-initializeropt
	::opt new new-placementopt ( type-id ) new-initializeropt

new-placement:
	( expression-list )

new-type-id:
	type-specifier-seq new-declaratoropt

new-declarator:
	ptr-operator new-declaratoropt
	noptr-new-declarator

noptr-new-declarator:
	[ expression ] attribute-specifier-seqopt
	noptr-new-declarator [ constant-expression ] attribute-specifier-seqopt

new-initializer:
	( expression-listopt )
	braced-init-list

delete-expression:
	::opt delete cast-expression
	::opt delete [ ] cast-expression

noexcept-expression:
	noexcept ( expression )

cast-expression:
	unary-expression
	( type-id ) cast-expression

pm-expression:
	cast-expression
	pm-expression .* cast-expression
	pm-expression ->* cast-expression

multiplicative-expression:
	pm-expression
	multiplicative-expression * pm-expression
	multiplicative-expression / pm-expression
	multiplicative-expression % pm-expression

additive-expression:
	multiplicative-expression
	additive-expression + multiplicative-expression
	additive-expression - multiplicative-expression

shift-expression:
	additive-expression
	shift-expression << additive-expression
	shift-expression >> additive-expression

relational-expression:
	shift-expression
	relational-expression < shift-expression
	relational-expression > shift-expression
	relational-expression <= shift-expression
	relational-expression >= shift-expression

equality-expression:
	relational-expression
	equality-expression == relational-expression
	equality-expression != relational-expression

and-expression:
	equality-expression
	and-expression & equality-expression

exclusive-or-expression:
	and-expression
	exclusive-or-expression ˆ and-expression

inclusive-or-expression:
	exclusive-or-expression
	inclusive-or-expression | exclusive-or-expression

logical-and-expression:
	inclusive-or-expression
	logical-and-expression && inclusive-or-expression

logical-or-expression:
	logical-and-expression
	logical-or-expression || logical-and-expression

conditional-expression:
	logical-or-expression
	logical-or-expression ? expression : assignment-expression

assignment-expression:
	conditional-expression
	logical-or-expression assignment-operator initializer-clause
	throw-expression

assignment-operator:
	= 
	*= 
	/= 
	%= 
	+= 
	-= 
	>>= 
	<<= 
	&= 
	ˆ= 
	|=

expression:
	assignment-expression
	expression , assignment-expression

constant-expression:
	conditional-expression

statement:
	labeled-statement
	attribute-specifier-seqopt expression-statement
	attribute-specifier-seqopt compound-statement
	attribute-specifier-seqopt selection-statement
	attribute-specifier-seqopt iteration-statement
	attribute-specifier-seqopt jump-statement
	declaration-statement
	attribute-specifier-seqopt try-block

labeled-statement:
	attribute-specifier-seqopt identifier : statement
	attribute-specifier-seqopt case constant-expression : statement
	attribute-specifier-seqopt default : statement

expression-statement:
	expressionopt ;

compound-statement:
	{ statement-seqopt }

statement-seq:
	statement
	statement-seq statement

selection-statement:
	if ( condition ) statement
	if ( condition ) statement else statement
	switch ( condition ) statement

condition:
	expression
	attribute-specifier-seqopt decl-specifier-seq declarator = initializer-clause
	attribute-specifier-seqopt decl-specifier-seq declarator braced-init-list

iteration-statement:
	while ( condition ) statement
	do statement while ( expression ) ;
	for ( for-init-statement conditionopt ; expressionopt ) statement
	for ( for-range-declaration : for-range-initializer ) statement

for-init-statement:
	expression-statement
	simple-declaration

for-range-declaration:
	attribute-specifier-seqopt decl-specifier-seq declarator

for-range-initializer:
	expression
	braced-init-list

jump-statement:
	break ;
	continue ;
	return expressionopt ;
	return braced-init-list ;
	goto identifier ;

declaration-statement:
	block-declaration

declaration-seq:
	declaration
	declaration-seq declaration

declaration:
	block-declaration
function-definition
template-declaration
explicit-instantiation
explicit-specialization
linkage-specification
namespace-definition
empty-declaration
attribute-declaration
block-declaration:
simple-declaration
asm-definition
namespace-alias-definition
using-declaration
using-directive
static_assert-declaration
alias-declaration
opaque-enum-declaration
alias-declaration:
using identifier attribute-specifier-seqopt = type-id ;
simple-declaration:
decl-specifier-seqopt init-declarator-listopt ;
attribute-specifier-seq decl-specifier-seqopt init-declarator-list ;
static_assert-declaration:
static_assert ( constant-expression , string-literal ) ;
empty-declaration:
;

attribute-declaration:
attribute-specifier-seq ;
decl-specifier:
storage-class-specifier
type-specifier
function-specifier
friend
typedef
constexpr
decl-specifier-seq:
decl-specifier attribute-specifier-seqopt
decl-specifier decl-specifier-seq
storage-class-specifier:
register
static
thread_local
extern
mutable
function-specifier:
inline
virtual
explicit
typedef-name:
identifier
type-specifier:
trailing-type-specifier
class-specifier
enum-specifier
trailing-type-specifier:
simple-type-specifier
elaborated-type-specifier
typename-specifier
cv-qualifier
type-specifier-seq:
type-specifier attribute-specifier-seqopt
type-specifier type-specifier-seq
trailing-type-specifier-seq:
trailing-type-specifier attribute-specifier-seqopt
trailing-type-specifier trailing-type-specifier-seq

simple-type-specifier:
nested-name-specifieropt type-name
nested-name-specifier template simple-template-id
char
char16_t
char32_t
wchar_t
bool
short
int
long
signed
unsigned
float
double
void
auto
decltype-specifier
type-name:
class-name
enum-name
typedef-name
simple-template-id
decltype-specifier:
decltype ( expression )
decltype ( auto )
elaborated-type-specifier:
class-key attribute-specifier-seqopt nested-name-specifieropt identifier
class-key nested-name-specifieropt templateopt simple-template-id
enum nested-name-specifieropt identifier
enum-name:
identifier
enum-specifier:
enum-head { enumerator-listopt }
enum-head { enumerator-list , }
enum-head:
enum-key attribute-specifier-seqopt identifieropt enum-baseopt
enum-key attribute-specifier-seqopt nested-name-specifier identifier
enum-baseopt
opaque-enum-declaration:
enum-key attribute-specifier-seqopt identifier enum-baseopt ;
enum-key:
enum
enum class
enum struct
enum-base:
: type-specifier-seq
enumerator-list:
enumerator-definition
enumerator-list , enumerator-definition
enumerator-definition:
enumerator
enumerator = constant-expression

enumerator:
identifier
namespace-name:
original-namespace-name
namespace-alias
original-namespace-name:
identifier
namespace-definition:
named-namespace-definition
unnamed-namespace-definition
named-namespace-definition:
original-namespace-definition
extension-namespace-definition
original-namespace-definition:
inlineopt namespace identifier { namespace-body }
extension-namespace-definition:
inlineopt namespace original-namespace-name { namespace-body }
unnamed-namespace-definition:
inlineopt namespace { namespace-body }
namespace-body:
declaration-seqopt
namespace-alias:
identifier
namespace-alias-definition:
namespace identifier = qualified-namespace-specifier ;
qualified-namespace-specifier:
nested-name-specifieropt namespace-name
using-declaration:
using typenameopt nested-name-specifier unqualified-id ;
using :: unqualified-id ;
using-directive:
attribute-specifier-seqopt using namespace nested-name-specifieropt namespace-name ;
asm-definition:
asm ( string-literal ) ;
linkage-specification:
extern string-literal { declaration-seqopt }
extern string-literal declaration
attribute-specifier-seq:
attribute-specifier-seqopt attribute-specifier
attribute-specifier:
[ [ attribute-list ] ]
alignment-specifier
alignment-specifier:
alignas ( type-id ...opt )
alignas ( assignment-expression ...opt )
attribute-list:
attributeopt
attribute-list , attributeopt
attribute ...
attribute-list , attribute ...
attribute:
attribute-token attribute-argument-clauseopt

attribute-token:
identifier
attribute-scoped-token
attribute-scoped-token:
attribute-namespace :: identifier
attribute-namespace:
identifier
attribute-argument-clause:
( balanced-token-seq )
balanced-token-seq:
balanced-tokenopt
balanced-token-seq balanced-token
balanced-token:
( balanced-token-seq )
[ balanced-token-seq ]
{ balanced-token-seq }
any token other than a parenthesis, a bracket, or a brace

init-declarator-list:
init-declarator
init-declarator-list , init-declarator
init-declarator:
declarator initializeropt
declarator:
ptr-declarator
noptr-declarator parameters-and-qualifiers trailing-return-type
ptr-declarator:
noptr-declarator
ptr-operator ptr-declarator
noptr-declarator:
declarator-id attribute-specifier-seqopt
noptr-declarator parameters-and-qualifiers
noptr-declarator [ expressionopt ] attribute-specifier-seqopt
( ptr-declarator )
parameters-and-qualifiers:
( parameter-declaration-clause ) cv-qualifier-seqopt
ref-qualifieropt exception-specificationopt attribute-specifier-seqopt
trailing-return-type:
-> trailing-type-specifier-seq abstract-declaratoropt
ptr-operator:
* attribute-specifier-seqopt cv-qualifier-seqopt
& attribute-specifier-seqopt
&& attribute-specifier-seqopt
nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt
cv-qualifier-seq:
cv-qualifier cv-qualifier-seqopt
cv-qualifier:
const
volatile
ref-qualifier:
&
&&

declarator-id:
...opt id-expression
type-id:
type-specifier-seq abstract-declaratoropt
abstract-declarator:
ptr-abstract-declarator
noptr-abstract-declaratoropt parameters-and-qualifiers trailing-return-type
abstract-pack-declarator
ptr-abstract-declarator:
noptr-abstract-declarator
ptr-operator ptr-abstract-declaratoropt
noptr-abstract-declarator:
noptr-abstract-declaratoropt parameters-and-qualifiers
noptr-abstract-declaratoropt [ constant-expressionopt ] attribute-specifier-seqopt
( ptr-abstract-declarator )
abstract-pack-declarator:
noptr-abstract-pack-declarator
ptr-operator abstract-pack-declarator
noptr-abstract-pack-declarator:
noptr-abstract-pack-declarator parameters-and-qualifiers
noptr-abstract-pack-declarator [ constant-expressionopt ] attribute-specifier-seqopt
...
parameter-declaration-clause:
parameter-declaration-listopt ...opt
parameter-declaration-list , ...
parameter-declaration-list:
parameter-declaration
parameter-declaration-list , parameter-declaration
parameter-declaration:
attribute-specifier-seqopt decl-specifier-seq declarator
attribute-specifier-seqopt decl-specifier-seq declarator = initializer-clause
attribute-specifier-seqopt decl-specifier-seq abstract-declaratoropt
attribute-specifier-seqopt decl-specifier-seq abstract-declaratoropt = initializer-clause
function-definition:
attribute-specifier-seqopt decl-specifier-seqopt declarator virt-specifier-seqopt function-body
function-body:
ctor-initializeropt compound-statement
function-try-block
= default ;
= delete ;
initializer:
brace-or-equal-initializer
( expression-list )
brace-or-equal-initializer:
= initializer-clause
braced-init-list
initializer-clause:
assignment-expression
braced-init-list
initializer-list:
initializer-clause ...opt
initializer-list , initializer-clause ...opt

braced-init-list:
{ initializer-list ,opt }
{}
class-name:
identifier
simple-template-id
class-specifier:
class-head { member-specificationopt }
class-head:
class-key attribute-specifier-seqopt class-head-name class-virt-specifieropt base-clauseopt
class-key attribute-specifier-seqopt base-clauseopt
class-head-name:
nested-name-specifieropt class-name
class-virt-specifier:
final
class-key:
class
struct
union
member-specification:
member-declaration member-specificationopt
access-specifier : member-specificationopt
member-declaration:
attribute-specifier-seqopt decl-specifier-seqopt member-declarator-listopt ;
function-definition ;opt
using-declaration
static_assert-declaration
template-declaration
alias-declaration
member-declarator-list:
member-declarator
member-declarator-list , member-declarator
member-declarator:
declarator virt-specifier-seqopt pure-specifieropt
declarator brace-or-equal-initializeropt
identifieropt attribute-specifier-seqopt : constant-expression
virt-specifier-seq:
virt-specifier
virt-specifier-seq virt-specifier
virt-specifier:
override
final
pure-specifier:
= 0
base-clause:
: base-specifier-list
base-specifier-list:
base-specifier ...opt
base-specifier-list , base-specifier ...opt
base-specifier:
attribute-specifier-seqopt base-type-specifier
attribute-specifier-seqopt virtual access-specifieropt base-type-specifier
attribute-specifier-seqopt access-specifier virtualopt base-type-specifier
class-or-decltype:
nested-name-specifieropt class-name
decltype-specifier
base-type-specifier:
class-or-decltype
access-specifier:
private
protected
public
conversion-function-id:
operator conversion-type-id
conversion-type-id:
type-specifier-seq conversion-declaratoropt
conversion-declarator:
ptr-operator conversion-declaratoropt
ctor-initializer:
: mem-initializer-list
mem-initializer-list:
mem-initializer ...opt
mem-initializer , mem-initializer-list ...opt
mem-initializer:
mem-initializer-id ( expression-listopt )
mem-initializer-id braced-init-list
mem-initializer-id:
class-or-decltype
identifier
operator-function-id:
operator operator
operator: one of
new delete
+
-
!
=
ˆ=
&=
<=
>=
()
[]
[gram.over]
new[]
*
<
|=
&&
delete[]
/
>
<<
||
%
+=
>>
++
ˆ
-=
>>=
--
&
*=
<<=
,
|
/=
==
->*
∼
%=
!=
->
literal-operator-id:
operator string-literal identifier
operator user-defined-string-literal

template-declaration:
template < template-parameter-list > declaration
template-parameter-list:
template-parameter
template-parameter-list , template-parameter
template-parameter:
type-parameter
parameter-declaration
type-parameter:
class ...opt identifieropt
class identifieropt = type-id
typename ...opt identifieropt
typename identifieropt = type-id
template < template-parameter-list > class ...opt identifieropt
template < template-parameter-list > class identifieropt = id-expression
simple-template-id:
template-name < template-argument-listopt >
template-id:
simple-template-id
operator-function-id < template-argument-listopt >
literal-operator-id < template-argument-listopt >
template-name:
identifier
template-argument-list:
template-argument ...opt
template-argument-list , template-argument ...opt
template-argument:
constant-expression
type-id
id-expression
typename-specifier:
typename nested-name-specifier identifier
typename nested-name-specifier templateopt simple-template-id
explicit-instantiation:
externopt template declaration
explicit-specialization:
template < > declaration
try-block:
try compound-statement handler-seq
function-try-block:
try ctor-initializeropt compound-statement handler-seq
handler-seq:
handler handler-seqopt
handler:
catch ( exception-declaration ) compound-statement
exception-declaration:
attribute-specifier-seqopt type-specifier-seq declarator
attribute-specifier-seqopt type-specifier-seq abstract-declaratoropt
...
throw-expression:
throw assignment-expressionopt
exception-specification:
dynamic-exception-specification
noexcept-specification
ynamic-exception-specification:
throw ( type-id-listopt )
type-id-list:
type-id ...opt
type-id-list , type-id ...opt
noexcept-specification:
noexcept ( constant-expression )
noexcept

