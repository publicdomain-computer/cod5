//**************************************************
// PSEUDO.C Functions to process pseudo-ops for XMAC
//**************************************************
// Written by John Goltz
//**************************************************

//++++
// This software is in the public domain.  It may be freely copied and used
// for whatever purpose you see fit, including commerical uses.  Anyone
// modifying this software may claim ownership of the modifications, but not
// the complete derived code.  It would be appreciated if the authors were
// told what this software is being used for, but this is not a requirement.

//   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
//   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
//   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
//   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
//   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//----

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <malloc.h>
#include <xos.h>
#include <xoserrmsg.h>
#include <xcstring.h>
#include <xcmalloc.h>
#include "xmac.h"

#define vv(f) (void (*)(void *))f


static void chrstring(void (*func)(int c, char *pnt), int addnull);
static void dirchr(int chr, char *pnt);
static void doblk(int size);
static void domod(int mod, int offset, int limit, int fill);
static void firstsection(void);
static int  getaval(ulong *value);
static int  getvalue(int chr, int radix);
static void lnkseg2(SN *s1name);
static void lowerchr(int chr, char *pnt);
static void pmsect2(void);
static void ppsect2(void);
static void proc80186(void);
static void proc80286(void);
static void proc80386(void);
static void proc80486(void);
static void proc80586(void);
static void proc8086(void);
static void pseg2(void);
static void upperchr(int chr, char *pnt);


//********************************************
// Function: ptitle - Process .TITLE pseudo-op
// Returned: Nothing
//********************************************

void ptitle(void)

{
	char *dpnt;
	char *spnt;
	int   cnt;
	char  chr;

    if (ttlflg)							// Have we seen a title?
    {
		errflag |= ERR_M;				// Yes - error
		skiprest();
		return;
    }
    ttlflg = TRUE;
    if (!getsym(nxtnbc()))				// Collect program name
    {
		queerr();
		return;
    }
	spnt = symbuf.nsym;
	dpnt = hdrbfr;
	cnt = SYMMAXSZ;
	while (--cnt >= 0 && (chr = *spnt++) != ' ')
		*dpnt++ = chr;
	*dpnt++ = ' ';
    copytext(dpnt, TITLESZ-SYMMAXSZ);
}


//********************************************
// Function: psbttl - Process .SBTTL pseudo-op
// Returned: Nothing
//********************************************

void psbttl(void)

{
    copytext(hdrstb, SBTTLSZ);			// Copy text to sub-title buffer
	listtoc();							// Output table of contents if wanted
}


//************************************************
// Function: copytexT - copy text to header buffer
// Returned: Nothing
//************************************************

void copytext(
    char *buffer,
    int   size)

{
    char chr;

    while (!eolflg)						// Copy text part to header buffer
    {
		chr = nxtchar();
		if (chr == ';')
		{
			skiprest();
			break;
		}
		if (--size >= 0)
			*buffer++ = (chr == '\t') ? ' ': chr;
    }
    *buffer = '\0';
    stopper = '\0';
}


//**********************************************
// Function: pfile - Process the .FILE pseudo-op
// Returned: Nothing
//**********************************************

// This pseudo-op is generated by GCC. It contains the name of the file being
//   compiled.  We strip off the extension and store the name as the title.
//   We ignore anything after the name.

void pfile(void)

{
	char *pnt;
	char *per;
	int   cnt;
	char  chr;

    if (!ttlflg && stopper == '"')
	{
		ttlflg = TRUE;
		nxtnbc();						// Discard the leading quote
		per = NULL;
		pnt = hdrbfr;
		cnt = TITLESZ - 2;
		while (--cnt >= 0 && (chr = nxtchar()) != '"' && !eolflg)
		{
			if (chr == '.')
				per = pnt;
			*pnt++ = chr;
		}
		if (per != NULL)
			*per = 0;
		else
			*pnt = 0;
	}
	skiprest();
}


//********************************************
// Function: pprint - Process .PRINT pseudo-op
// Returned: Nothing
//********************************************

void pprint(void)

{
    errflag |= ERR_XX;					// Set non-error error bit!
    skiprest();							// Skip rest of the line
}


//********************************************
// Function: perror - Process .ERROR pseudo-op
// Returned: Nothing
//********************************************

void peerror(void)

{
    errflag |= ERR_E;					// Indicate E error
    skiprest();							// Skip rest of the line
}


//**********************************************
// Function: pinclud -  Handle .INCLUD pseudo-op
// Returned: Nothing
//**********************************************

void pinclud(void)

{
    char *pnt;
    int   cnt;
    char  chr;

    if (srclvl >= INCLMAX)				// Level too deep?
    {
		fprintf(stderr, "? XMAC: Include level too deep from file %s\n",
                srcfsp[INCLMAX]);
		exit (1);
    }
	pnt = getspace ((long)(INCLFSSZ+1));
	srcfsp[srclvl+1] = pnt;
    cnt = INCLFSSZ;
    chr = nxtnbc ();
    while (!eolflg && chr != ';' && !isspace(chr))
    {
 		if (--cnt < 0)
		{
			fprintf(stderr, "? XMAC: Include file specification \"%s\" too "
					"long\n", srcfsp[srclvl+1]);
			exit (1);
		}
		*pnt++ = chr;
		chr = nxtchar();
    }
    *pnt = '\0';
    stopper = chr;
    if (!ifend(chr))
    {
		fprintf(stderr, "? XMAC: Syntax error in include statement from "
				"file %s\n", srcfsp[srclvl]);
		exit (1);
    }

	clstoretext();
    advanceline();						// Advance to next line
    ++srclvl;
    srcfp[srclvl] = fopen(srcfsp[srclvl], "r"); // Open the file
    if (srcfp[srclvl] == NULL)
		femsg("XMAC(.INCLUD)", -errno, srcfsp[srclvl]); // If error
    savlineno[srclvl] = lineno;			// Save current input line number
    savlinesz[srclvl] = linesz;
	if (prmcnt > 0)
		prmcnt++;
    lineno = 1;							// Initialize line number for
}										//   this file


//**********************************************
// Function: prequir -  Handle .REQUIR pseudo-op
// Returned: Nothing
//**********************************************

void prequir(void)

{
    struct reqblk *reqpnt;
    char  *pnt;
    int    cnt;
    char   chr;
    char   buffer[204];

    pnt = buffer;
    cnt = 200;
    chr = nxtnbc();
    while (!eolflg && chr != ';' && !isspace(chr))
    {
		if (--cnt < 0)
		{
            errflag |= ERR_IN;
            return;
		}
		*pnt++ = chr;
		chr = nxtchar();
    }
    *pnt = '\0';
    cnt = 200 - cnt;
    stopper = chr;
    if (!ifend(chr))
    {
        errflag |= ERR_IN;
        return;
    }
    advanceline();						// Advance to next line
    reqpnt = reqhead;					// See if we already have this one
    while (reqpnt != NULL)
    {
        if (cnt == reqpnt->size && strcmp(buffer, reqpnt->name) == 0)
            return;						// Have it - ignore this request
        reqpnt = reqpnt->next;
    }
    reqpnt = (struct reqblk *)getspace(cnt + offsetof(struct reqblk, name) + 2);
    strcpy(reqpnt->name, buffer);		// Don't have it - allocate a block
    reqpnt->size = cnt;					//   and store the request
    reqpnt->next = NULL;
    if (reqtail == NULL)
        reqhead = reqpnt;
    else
        reqtail->next = reqpnt;
    reqtail = reqpnt;
}


//********************************************
// Function: pradix - Process .RADIX pseudo-op
// Returned: Nothing
//********************************************

void pradix(void)

{
	VL val;

    iradix = 10;						// Always evalulate the expresssion
    exprsn(&val);						//   using radix 10
    if (val.kind != VLK_ABS)
    {
        errorx();
		skiprest();
		return;
    }
    if (!chkend(stopper))				// Must have end next
		return;
    val.val &= 0xF;
    if (val.val == 0)					// If value is 0
		val.val = 16;					// Use 16
    iradix = val.val;					// Store as new default radix

///// GENERATE LSTVAL ELEMENT HERE

}


//******************************************
// Function: ppage - Process .PAGE pseudo-op
// Returned: Nothing
//******************************************

void ppage(void)

{
    if (chkendx() && nlscnt >= 0)		// Must have end of line next
    {									//   and be listing now
        albcnt = 0;						// Don't list this line
		pagcnm = 0;						// Reset continuation number
	    lstseq = 1;						// Reset sequence number
	    ++pagnum;						// Bump page number
    	++lsbnum;						// Bump local symbol block number
    }
}


//****************************************
// Function: plsb - Process .LSB pseudo-op
// Returned: Nothing
//****************************************

void plsb(void)

{
    if (chkendx())						// Must have end of line next
		++lsbnum;
}


//********************************************
// Function: pnlist - Process .NLIST pseudo-op
// Returned: Nothing
//********************************************

void pnlist(void)

{
    if (chkendx())
		--nlscnt;
}


//******************************************
// Function: plist - Process .LIST pseudo-op
// Returned: Nothing
//******************************************

void plist(void)

{
    if (chkendx() && nlscnt++ < 0)		// Are we listing now?
		albcnt = 0;							// No - don't list this line
}


//******************************************
// Function: pcref - Process .CREF pseudo-op
// Returned: Nothing
//******************************************

void pcref(void)

{
    if (chkendx() && listtype == LT_CREF)
		++crfcnt;
}


//********************************************
// Function: pncref - Process .NCREF pseudo-op
// Returned: Nothing
//********************************************

void pncref(void)

{
    if (chkendx() && listtype == LT_CREF)
		--crfcnt;
}


//********************************************
// Function: palmex - Process .ALMEX pseudo-op
// Returned: Nothing
//********************************************

void palmex(void)

{
    if (chkendx())
		lstmode = 2;
}


//********************************************
// Function: pslmex - Process .SLMEX pseudo-op
// Returned: Nothing
//********************************************

void pslmex(void)

{
    if (chkendx())
		lstmode = 0;
}


//********************************************
// Function: pblmex - Process .BLMEX pseudo-op
// Returned: Nothing
//********************************************

void pblmex(void)

{
    if (chkendx())
		lstmode = 1;
}


//********************************************
// Function: pnlmex - Process .NLMEX pseudo-op
// Returned: Nothing
//********************************************

void pnlmex(void)

{
    if (chkendx())
		lstmode = -1;
}


//******************************************
// Function: plbex - Process .LBEX pseudo-op
// Returned: Nothing
//******************************************

void plbex(void)

{
    if (chkendx())
		bexflg = FALSE;
}


//********************************************
// Function: pnlbex - Process .NLBEX pseudo-op
// Returned: Nothing
//********************************************

void pnlbex(void)

{
    if (chkendx())
		bexflg = TRUE;
}


//******************************************
// Function: plsym - Process .LSYM pseudo-op
// Returned: Nothing
//******************************************

void plsym(void)

{
    if (chkendx())
        lsymflg = TRUE;
}


//********************************************
// Function: pnlsym - Process .NLSYM pseudo-op
// Returned: Nothing
//********************************************

void pnlsym(void)

{
    if (chkendx())
        lsymflg = FALSE;
}

//********************************************
// Function: pngsym - Process .NGSYM pseudo-op
// Returned: Nothing
//********************************************

void pngsym(void)

{
    if (chkendx())
        gsymflg = FALSE;
}


//****************************************
// Function: pcot - Process .COT pseudo-op
// Returned: Nothing
//****************************************

void pcot(void)

{
    if (chkendx())
		tocflg = TRUE;
}


//******************************************
// Function: pncot - Process .NCOT pseudo-op
// Returned: Nothing
//******************************************

void pncot(void)

{
    if (chkendx())
		tocflg = FALSE;
}


//******************************************
// Function: pparm - Process .PARM pseudo-op
// Returned: Nothing
//******************************************

void pparm(void)

{
    if (!chkendx())
		return;
    if (inspnt)							// Are we inserting?
    {
		badopcode();					// Yes - error
		return;
    }
    if (!nopar && prmcnt <= 0)
		prmcnt++;
}


//*****************************************
// Attributes table for the .PROC pseudo-op
//*****************************************

struct atributes proctbl[] =
{	{{'8','0','1','8','6',' '}, vv(proc80186)},
	{{'8','0','2','8','6',' '}, vv(proc80286)},
	{{'8','0','3','8','6',' '}, vv(proc80386)},
	{{'8','0','4','8','6',' '}, vv(proc80486)},
	{{'8','0','5','8','6',' '}, vv(proc80586)},
	{{'8','0','8','6',' ',' '}, vv(proc8086)}
};
#define PRSIZE (sizeof(proctbl)/sizeof(struct atributes))


//******************************************
// Function: pproc - Process .PROC pseudo-op
// Returned: Nothing
//******************************************

void pproc(void)

{
    hndlatr(proctbl, PRSIZE, NULL);
    chkend(stopper);
}


//****************************************************************
// Function: proc8086 - Process 8086 attribute for .PROC pseudo-op
// Returned: Nothing
//****************************************************************

static void proc8086(void)

{
    if (ptype && ptype != P_8086)
        errorc();
    else
    {
        ptype = P_8086;
        pbits = B_8086;
        stack32 = FALSE;
    }
}


//******************************************************************
// Function: proc80186 - Process 80186 attribute for .PROC pseudo-op
// Returned: Nothing
//******************************************************************

static void proc80186(void)

{
    if (ptype && ptype != P_80186)
        errorc();
    else
    {
        ptype = P_80186;
        pbits = B_80186;
        stack32 = FALSE;
    }
}


//******************************************************************
// Function: proc80286 - Process 80286 attribute for .PROC pseudo-op
// Returned: Nothing
//******************************************************************

static void proc80286(void)

{
    if (ptype && ptype != P_80286)
        errorc();
    else
    {
        ptype = P_80286;
        pbits = B_80286;
        stack32 = FALSE;
    }
}


//******************************************************************
// Function: proc80386 - Process 80386 attribute for .PROC pseudo-op
// Returned: Nothing
//******************************************************************

static void proc80386(void)

{
    if (ptype && ptype != P_80386)
        errorc();
    else
    {
        ptype = P_80386;
        pbits = B_80386;
        stack32 = TRUE;
    }
}


//******************************************************************
// Function: proc80486 - Process 80486 attribute for .PROC pseudo-op
// Returned: Nothing
//******************************************************************

static void proc80486(void)

{
    if (ptype && ptype != P_80486)
        errorc();
    else
    {
        ptype = P_80486;
        pbits = B_80486;
        stack32 = TRUE;
    }
}


//******************************************************************
// Function: proc80586 - Process 80586 attribute for .PROC pseudo-op
// Returned: Nothing
//******************************************************************

static void proc80586(void)

{
    if (ptype && ptype != P_80586)
        errorc();
    else
    {
        ptype = P_80586;
        pbits = B_80586;
        stack32 = TRUE;
    }
}


//****************************************************
// Function: puleb128 - Process the .ULEB128 pseudo-op
// Returned: Nothing
//****************************************************

// This pseudo-op contains DWARF debugging data. We ignore it for now.

void puleb128(void)

{
	skiprest();
}


//****************************************************
// Function: psleb128 - Process the .SLEB128 pseudo-op
// Returned: Nothing
//****************************************************

// This pseudo-op contains DWARF debugging data. We ignore it for now.

void psleb128(void)

{
	skiprest();
}


//********************************************
// Function: ploc - Process the .LOC pseudo-op
// Returned: Nothing
//********************************************

// This pseudo-op is generated by GCC and contains line numbers for
//   debugging - we use it to define symbols of the form $nnnn where
//   nnnn is the line number

void ploc(void)

{
	VL  val;
	CL *clp;
	SY *sym;

    getabs(&val);						// Get and ignore first value
	hldchar = stopper;
	getabs(&val);						// Get line number
	if (errflag != 0)
		return;
	symsize = sprintf(symbuf.nsym, "$%d", val.val);
	chkpsect();							// Must have psect defined
	sym = findsym(TRUE);				// Look for symbol in symbol table
	if (sym->sy_flag & SYF_UNDEF)		// Is it undefined now?
	{
		sym->sy_flag &= ~SYF_UNDEF;
		sym->sy_flag |= SYF_LABEL|SYF_ADDR; // Yes - indicate this is
										    //   a label and address
		sym->sy_val.val = curpsd->pd_ofs; // Value is current address
		sym->sy_psect = curpsd->pd_psn;
	}
	clp = clget(CL_LABEL_SZ);
	clp->type = CLT_LABEL;
	clp->offset = curpsd->pd_ofs;
	clp->lsym = sym;
	clinsert(clp);
	skiprest();
}


//************************************************
// Function: pident - Process the .IDENT pseudo-op
// Returned: Nothing
//************************************************

// This pseudo-op contains identification information generated by GCC. We
//   ignore it for now.

void pident(void)

{
	skiprest();
}


typedef struct 
{	char *secname;
	int   chklen;
	int   done;
	char *segname;
	char *msectname;
	char *msectatr;
	char *psectname;
} SECTBL;

static SECTBL sectbl[] =
{	{".data"   , 5, 0, "DGROUP_s", "DGROUP_m", "read,write", "_DATA"},
	{".bss"    , 4, 0, "DGROUP_s", "DGROUP_m", "read,write", "_BSS"},
	{".debug_?", 7, 0, "DGROUP_s", "DGROUP_m", "read,write", "_DEBUG_"},
	{".text"   , 5, 0, "_TEXT_s" , "_TEXT_m" , "read"      , "_TEXT"}
};


//************************************************
// Function: psection - Process .SECTION pseudo-op
// Returned: Nothing
//************************************************

// This pseudo-op is generated by GCC to specify program "sections". A
//   GCC section is mapped to an XOS psect as follows:
//     Section     Msect    Segment  Psect      Segment attributes
//     .text       _TEXT_m  _TEXT_s  _TEXT_p    code,32bit
//     .data       DGROUP_m DGROUP_s _DATA_p    data,32bit
//     .bss        DGROUP_m DGROUP_s _BSS_p     data,32bit
//     .debug_xxx  _DEBUG_m DGROUP_s _DEBUG_xxx data,32bit
// xxx can be any string.

void psection(void)

{
	static IC  icb = {NULL, NULL, NULL, NULL, 0, 0, 0, ICT_STATIC, 0};

	SECTBL *tblp;
	char   *pnt;
	char   *cpnt;
	char   *savealbpnt;
	int     cnt;
	int     ccnt;
	int     savealbcnt;
	char    psectname[64];
	char    bufr[128];
	char    chr;

    if (ptype == 0)
        ptype = P_80386;
    if (!getsym(nxtnbc()))				// Collect segment name
    {
        errflag |= ERR_Q;
        return;
    }
    else								// Collect rest of symbol if stopped
		persym();						//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
	tblp = sectbl;
	cnt = sizeof(sectbl)/sizeof(SECTBL);
	skiprest();
	savealbpnt = albpnt;
	savealbcnt = albcnt;
	do
	{
		if (strncmp(symbuf.nsym, tblp->secname, tblp->chklen) == 0 &&
				(tblp->secname[tblp->chklen] == '?' ||
				symbuf.nsym[tblp->chklen] == ' '))
		{
			pnt = strnmov(psectname, tblp->psectname, tblp->chklen);
			if (tblp->secname[tblp->chklen] == '?')
			{
				ccnt = 16;
				cpnt = symbuf.nsym + tblp->chklen;
				while (--ccnt >= 0 && (chr = *cpnt++) != 0 && chr != ' ')
					*pnt++ = chr;
			}
			pnt = strmov(pnt, "_p");

			if (!havesection)
				firstsection();
			if (!tblp->done)
			{
				tblp->done = TRUE;

				// Fake up a .MSECT pseudo-op

				sprintf(symbuf.nsym, "%-*s", SYMMAXSZ, tblp->msectname);
				symsize = strlen(tblp->msectname);
				sprintf(bufr, "%s,%s"CCSTR_EST, tblp->segname, tblp->msectatr);
				icb.ic_cbc = 100;
				icb.ic_link = inspnt;
				icb.ic_cbp = bufr;
				inspnt = &icb;
				eolflg = FALSE;
				stopper = ',';
				pmsect2();
			}

			// Fake up a .PSECT pseudo-op

			sprintf(symbuf.nsym, "%-*s", SYMMAXSZ, psectname);
			symsize = pnt - psectname;
			sprintf(bufr, "%s,mod=4"CCSTR_EST, tblp->msectname);
			icb.ic_cbc = 100;
			icb.ic_link = inspnt;
			icb.ic_cbp = bufr;
			inspnt = &icb;
			eolflg = FALSE;
			stopper = ',';
			ppsect2();
			albpnt = savealbpnt;
			albcnt = savealbcnt;
			return;
		}
		tblp++;
	} while (--cnt > 0);
	errflag |= ERR_U;
	albpnt = savealbpnt;
	albcnt = savealbcnt;
}


static void firstsection(void)

{
	IC  icb = {NULL, NULL, NULL, NULL, 0, 0, 0, ICT_STATIC, 0};
	SN *s1name;

	havesection = TRUE;
	sprintf(symbuf.nsym, "%-*s", SYMMAXSZ, "DGROUP_s");
	symsize = 8;
	icb.ic_cbc = 100;
	icb.ic_link = inspnt;
	icb.ic_cbp = "32bit,data,read,write"CCSTR_EST;
	inspnt = &icb;
	eolflg = FALSE;
	stopper = ',';
	pseg2();

	sprintf(symbuf.nsym, "%-*s", SYMMAXSZ, "_TEXT_s");
	symsize = 7;
	icb.ic_cbc = 100;
	icb.ic_link = inspnt;
	icb.ic_cbp = "32bit,code,read"CCSTR_EST;
	inspnt = &icb;
	eolflg = FALSE;
	stopper = ',';
	pseg2();

	sprintf(symbuf.nsym, "%-*s", SYMMAXSZ, "_TEXT_s");
	symsize = 7;
	if ((s1name = (struct sn *)looksym()) == NULL)
	{						// Look for _TEXT_s in the symbol table
		errflag |= ERR_I;	// Error if not defined
		return;
	}
	sprintf(symbuf.nsym, "%-*s", SYMMAXSZ, "DGROUP_s");
	symsize = 8;
	lnkseg2(s1name);
}


//****************************************
// Attributes table for the .SEG pseudo-op
//****************************************

struct atributes satrtbl[] =
{   {{'1','6','B','I','T',' '}, vv(satr16b)},
    {{'3','2','B','I','T',' '}, vv(satr32b)},
    {{'A','D','D','R',' ',' '}, vv(satraddr)},
    {{'C','O','D','E',' ',' '}, vv(satrcode)},
    {{'C','O','M','B',' ',' '}, vv(satrcomb)},
    {{'C','O','N','F',' ',' '}, vv(satrconf)},
    {{'D','A','T','A',' ',' '}, vv(satrdata)},
    {{'E','X','T','E','N','D'}, vv(satrext)},
    {{'L','A','R','G','E',' '}, vv(satrlarge)},
    {{'M','O','D',' ',' ',' '}, vv(satrmod)},
    {{'P','R','I','V',' ',' '}, vv(satrpriv)},
    {{'R','E','A','D',' ',' '}, vv(satrread)},
    {{'S','E','L','E','C','T'}, vv(satrselect)},
    {{'S','T','A','C','K',' '}, vv(satrstack)},
    {{'W','R','I','T','E',' '}, vv(satrwrite)}
};
#define SASIZE (sizeof(satrtbl)/sizeof(struct atributes))

//****************************************
// Function: pseg - Process .SEG pseudo-op
// Returned: Nothing
//****************************************

void pseg(void)

{
    if (ptype == 0)
        ptype = P_8086;
    if (!getsym(nxtnbc()))				// Collect segment name
    {
        errorq();
        return;
    }
    else								// Collect rest of symbol if stopped
		persym();						//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
	pseg2();
}


static void pseg2(void)

{
	SN  *sname;
    SD  *sgd;
    long addr;
    int  select;
    char atrb;
    char flag;

    sname = (struct sn *)looksym();	// Look for it in the symbol table
    if (sname == NULL || (sname->sn_flag&SYF_UNDEF)) // If not defined
    {
        if (sgtail && sgtail->sd_sgn == 254)
        {								// Not there - room for another?
            fputs("? XMAC: Too many segments\n", stderr);
            exit(1);
        }
        if (sname == NULL)
            sname = (struct sn *)entersym(); // OK - put name block in symbol
		else								 //   table
            sname->sn_flag &= ~SYF_UNDEF;
        sname->sn_type = SYT_SEG;
        sgd = (SD *)getblock(); 		// Get block for segment data block
        sgd->sd_nba = sname;			// Initialize it
        sgd->sd_sgn = (sgtail)? sgtail->sd_sgn + 1: 0x201;
        sgd->sd_atrb = (ptype >= P_80386)? SA_32BIT: 0;
        sgd->sd_flag = 0;
        sgd->sd_priv = 0;
        sgd->sd_type = 0;
        sgd->sd_select = 0;
        sgd->sd_addr = -1;
        if (sgtail)
            sgtail->sd_next = sgd;
        else
            sghead = sgd;
        sgtail = sgd;
        sgd->sd_next = NULL;
        sname->sn_sgn = sgd->sd_sgn;
        sname->sn_flag = 0;
        sname->sn_dba = sgd;
        while (stopper == ',')
            hndlatr(satrtbl, SASIZE, (struct pd *)sgd);
        if (sgd->sd_type == 0)
            sgd->sd_type = ST_COMB;
    }
    else
    {
        sgd = sname->sn_dba;
        atrb = sgd->sd_atrb;
        flag = sgd->sd_flag;
        addr = sgd->sd_addr;
        select = sgd->sd_select;
        while (stopper == ',')
            hndlatr(satrtbl, SASIZE, (struct pd *)sgd);
        if (sgd->sd_atrb != atrb || sgd->sd_flag != flag ||
                sgd->sd_addr != addr || sgd->sd_select != select)
        {
            errorc();
            sgd->sd_atrb = atrb;
            sgd->sd_flag = flag;
            sgd->sd_addr = addr;
            sgd->sd_select = select;
        }
    }
    chkend(stopper);
}


//*****************************************************************
// Function: satrlarge - Process LARGE attribute for .SEG pseudo-op
// Returned: Nothing
//*****************************************************************

void satrlarge(
    SD *sgd)

{
    sgd->sd_atrb |= SA_LARGE;
}


//****************************************************************
// Function: satrext - Process EXTEND attribute for .SEG pseudo-op
// Returned: Nothing
//****************************************************************

void satrext(
    SD *sgd)

{
    sgd->sd_atrb |= SF_EXTEND;
}


//***************************************************************
// Function: satr16b - Process 16BIT attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satr16b(
    SD *sgd)

{
    sgd->sd_atrb &= ~SA_32BIT;
}


//*****************************************************************
// Function: satr32bit - Process 32bit attribute for .SEG pseudo-op
// Returned: Nothing
//*****************************************************************

void satr32b(
    SD *sgd)

{
    if (ptype >= P_80386)
        sgd->sd_atrb |= SA_32BIT;
    else
        queerr();
}


//***************************************************************
// Function: satrconf - Process CONF attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satrconf(
    SD *sgd)

{
    sgd->sd_atrb |= SA_CONF;
}

//*****************************************************************
// Function: satrwrite - Process WRITE attribute for .SEG pseudo-op
// Returned: Nothing
//*****************************************************************

void satrwrite(
    SD *sgd)

{
    sgd->sd_atrb |= SA_WRITE;
}

//***************************************************************
// Function: satrread - Process READ attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satrread(
    SD *sgd)

{
    sgd->sd_atrb |= SA_READ;
}

//***************************************************************
// Function: satrdata - Process DATA attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satrdata(
    SD *sgd)

{
    sgd->sd_type = ST_DATA;
}

//***************************************************************
// Function: satrcode - Process CODE attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satrcode(
    SD *sgd)

{
    sgd->sd_type = ST_CODE;
}

//*****************************************************************
// Function: satrstack - Process STACK attribute for .SEG pseudo-op
// Returned: Nothing
//*****************************************************************

void satrstack(
    SD *sgd)

{
    sgd->sd_type = ST_STACK;
}

//***************************************************************
// Function: satrcomb - Process COMB attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satrcomb(
    SD *sgd)

{
    sgd->sd_type = ST_COMB;
}

//***************************************************************
// Function: satrpriv - Process PRIV attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satrpriv(
    SD *sgd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value > 3)
            errorx();
        else
            sgd->sd_priv = value;
    }
}

//*******************************************************************
// Function: satrselect - Process SELECT attribute for .SEG pseudo-op
// Returned: Nothing
//*******************************************************************

void satrselect(
    SD *sgd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0)
            errorx();
        else
            sgd->sd_select = value;
    }
}

//***************************************************************
// Function: satraddr - Process ADDR attribute for .SEG pseudo-op
// Returned: Nothing
//***************************************************************

void satraddr(
    SD *sgd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFL)
            errorx();
        else
        {
            sgd->sd_addr = value;
            sgd->sd_flag |= SF_ADDR;
        }
    }
}

//*************************************************************
// Function: satrmod - Process MOD attribute for .SEG pseudo-op
// Returned: Nothing
//*************************************************************

void satrmod(
    SD *sgd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFFFL)
            errorx();
        else
        {
            sgd->sd_addr = value;
            sgd->sd_flag &= ~SF_ADDR;
        }
    }
}

//********************************************
// Function: pseg16 - Process .SEG16 pseudo-op
// Returned: Nothing
//********************************************

void pseg16(void)

{
    if (chkendx())
        segatrb &= ~SA_32BIT;
}

//********************************************
// Function: pseg32 - Process .SEG32 pseudo-op
// Returned: Nothing
//********************************************

void pseg32(void)

{
    if (chkendx())
        segatrb |= SA_32BIT;
}

//**********************************************
// Function: plnkseg - Process .LNKSEG pseudo-op
// Returned: Nothing
//**********************************************

void plnkseg(void)

{
    SN *s1name;

    if (!getsym(nxtnbc()))				// Collect first segment name
    {
        errorq();
        return;
    }
    else								// Collect rest of symbol if stopped
		persym();						//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
    if ((s1name = (struct sn *)looksym()) == NULL)
    {									// Look for it in the symbol table
        errflag |= ERR_I;				// Error if not defined
        return;
    }
    if (stopper != ',' || !getsym(nxtnbc())) // Collect second segment name
    {
        errorq();
        return;
    }
    else								// Collect rest of symbol if stopped
		persym();						//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
	lnkseg2(s1name);
}


static void lnkseg2(
	SN *s1name)

{
	SN *s2name;
    SD *s1dba;
    SD *s2dba;


    s1dba = s1name->sn_dba;
    if ((s2name = (struct sn *)looksym()) == NULL || s1name == s2name ||
            ( (((s2dba = s2name->sn_dba)->sd_flag & SF_LINKED) ||
            (s1dba->sd_flag & SF_LINKED)) &&
            (s2dba->sd_linked != s1dba || s1dba->sd_linked != s2dba)))
    {									// Look for it in the symbol table
        errflag |= ERR_I;				// Error if not defined or if same
        return;							//   or if either segment already
    }									//   linked
    if (!chkend(stopper))				// Must have end of line here
        return;
    s1dba->sd_linked = s2dba;			// Link the two segments
    s1dba->sd_flag |= SF_LINKED;
    s2dba->sd_linked = s1dba;
    s2dba->sd_flag |= SF_LINKED;
}

//******************************************
// Attributes table for the .MSECT pseudo-op
//******************************************

struct atributes matrtbl[] =
{   {{'A','D','D','R',' ',' '}, vv(matraddr)},
    {{'M','A','X',' ',' ',' '}, vv(matrmax)},
    {{'M','O','D',' ',' ',' '}, vv(matrmod)},
    {{'R','E','A','D',' ',' '}, vv(matrread)},
    {{'W','R','I','T','E',' '}, vv(matrwrite)}
};
#define MASIZE (sizeof(matrtbl)/sizeof(struct atributes))

//********************************************
// Function: pmsect - Process .MSECT pseudo-op
// Returned: Nothing
//********************************************

void pmsect(void)

{
    if (ptype == 0)
        ptype = P_8086;
    if (!getsym(nxtnbc()))				// Collect msect name
    {
        errorq();
        return;
    }
    else								// Collect rest of symbol if stopped
		persym();						//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
	pmsect2();
}


static void pmsect2(void)

{
    MN  *mname;
    SN  *sname;
    MD  *msd;
    long addr;
    long max;
    char atrb;
    char flag;

    mname = (struct mn *)looksym();		// Look for it in the symbol table
    if (mname == NULL || (mname->mn_flag&SYF_UNDEF))
    {
        if (mstail && mstail->md_msn == 254)
        {								// Not there - room for another?
            fputs("? XMAC: Too many msects\n", stderr);
            exit(1);
        }
        if (mname == NULL)
            mname = (struct mn *)entersym(); // OK - put name block in symbol
		else								 //   table
            mname->mn_flag &= ~SYF_UNDEF;
        mname->mn_type = SYT_MSC;
        msd = (MD *)getblock();			// Block for msect data block
        msd->md_nba = mname;			// Initialize it
        msd->md_addr = -1;
        msd->md_max = -1;
        msd->md_msn = (mstail)? mstail->md_msn + 1: 0x101;
        msd->md_atrb = 0;
        msd->md_flag = 0;
        msd->md_sgn = 0;
        msd->md_sdb = NULL;
        msd->md_next = msd;
        mname->mn_msn = msd->md_msn;
        mname->mn_flag = 0;
        mname->mn_dba = msd;
    }
    else
        msd = mname->mn_dba;
    if (stopper == ',')
    {
        if (!getsym(nxtnbc()))			// Collect segment name
        {
            errflag |= ERR_I;
            return;
        }
        else							// Collect rest of symbol if stopped
            persym();					//   here by a period
        if (isspace(stopper))
            stopper = nxtnbc();
        sname = (struct sn *)looksym(); // Look for it in the symbol table
        if (sname == NULL || sname->sn_type != SYT_SEG)
        {
            errflag |= ERR_I;
            return;
        }
        else
        {
            if (msd->md_sdb)
            {
                if (msd->md_sdb->sd_nba != sname)
                {
                    errflag |= ERR_DN;
                    return;
                }
            }
            else
            {
                msd->md_sgn = sname->sn_sgn;
                msd->md_sdb = sname->sn_dba;
            }
        }
    }
    else								// No segment specified        
    {
        if (msd->md_sdb == NULL)		// Already have a segment?
        {
            errflag |= ERR_I;			// No - error
            return;
        }
    }
    while (stopper == ',')
        hndlatr(matrtbl, MASIZE, (struct pd *)msd);
    if (msd->md_next == msd)			// Is this block linked yet?
    {
        if (mstail)						// No - link it now
            mstail->md_next = msd;
        else
            mshead = msd;
        mstail = msd;
        msd->md_next = NULL;
        while (stopper == ',')
            hndlatr(matrtbl, MASIZE, (struct pd *)msd);
    }
    else
    {
        atrb = msd->md_atrb;
        flag = msd->md_flag;
        addr = msd->md_addr;
        max = msd->md_max;
        while (stopper == ',')
            hndlatr(matrtbl, MASIZE, (struct pd *)msd);
        if (msd->md_atrb != atrb || msd->md_flag != flag ||
                msd->md_addr != addr || msd->md_max != max)
        {
            errorc();
            msd->md_atrb = atrb;
            msd->md_flag = flag;
            msd->md_addr = addr;
            msd->md_max = max;
        }
    }
    chkend(stopper);
}


//***************************************************************
// Function: matrmax - Process MAX attribute for .MSECT pseudo-op
// Returned: Nothing
//***************************************************************

void matrmax(
    MD *msd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFFFL)
            errorx();
        else
            msd->md_max = value;
    }
}


//*******************************************************************
// Function: matrwrite - Process WRITE attribute for .MSECT pseudo-op
// Returned: Nothing
//*******************************************************************

void matrwrite(
    MD *msd)

{
    msd->md_atrb |= MA_WRITE;
}


//*****************************************************************
// Function: matrread - Process READ attribute for .MSECT pseudo-op
// Returned: Nothing
//*****************************************************************

void matrread(
    MD *msd)

{
    msd->md_atrb |= MA_READ;
}


//*****************************************************************
// Function: matraddr - Process ADDR attribute for .MSECT pseudo-op
// Returned: Nothing
//*****************************************************************

void matraddr(
    MD *msd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFFFL)
            errorx();
        else
        {
            msd->md_addr = value;
            msd->md_flag |= MF_ADDR;
        }
    }
}


//***************************************************************
// Function: matrmod - Process MOD attribute for .MSECT pseudo-op
// Returned: Nothing
//***************************************************************

void matrmod(
    MD *msd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFFFL)
            errorx();
        else
        {
            msd->md_addr = value;
            msd->md_flag &= ~MF_ADDR;
        }
    }
}


//******************************************
// Attributes table for the .PSECT pseudo-op
//******************************************

struct atributes patrtbl[] =
{   {{'A','D','D','R',' ',' '}, vv(patraddr)},
    {{'M','O','D',' ',' ',' '}, vv(patrmod)},
    {{'O','V','E','R',' ',' '}, vv(patrover)}
};
#define PASIZE (sizeof(patrtbl)/sizeof(struct atributes))

//********************************************
// Function: ppsect - Process .PSECT pseudo-op
// Returned: Nothing
//********************************************

void ppsect(void)

{
    if (ptype == 0)
        ptype = P_8086;
    if (!getsym(nxtnbc()))				// Collect psect name
    {
        errorq();
        return;
    }
    else								// Collect rest of symbol if stopped
		persym();						//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
	ppsect2();
}


static void ppsect2(void)

{
    struct pn *pname;
    struct mn *mname;
    struct pd *psd;
    long   addr;
	int    mod;
    char   atrb;
    char   flag;

    pname = (struct pn *)looksym();		// Look for it in the symbol table
    if (pname == NULL || (pname->pn_flag&SYF_UNDEF))
    {
        if (pstail && pstail->pd_psn == 254)
        {								// Not there - room for another?
            fputs("? XMAC: Too many psects - cannot continue\n", stderr);
            exit(1);
        }
        if (pname == NULL)
            pname = (struct pn *)entersym(); // OK - put name block in symbol
        else								 //   table
            pname->pn_flag &= ~SYF_UNDEF;
        pname->pn_type = SYT_PSC;
        psd = (struct pd *)getblock();	// Get block for psect data block
        psd->pd_nba = pname;			// Initialize it
        psd->pd_ofs = 0;
        psd->pd_tsize = 0;
        psd->pd_lsize = 0;
        psd->pd_psn = (pstail)? pstail->pd_psn + 1: 1;
        psd->pd_atrb = 0;
        psd->pd_flag = 0;
        psd->pd_msn = 0;
        psd->pd_mdb = NULL;
        psd->pd_next = psd;
        psd->pd_address = 0xFFFFFFFFL;
		psd->pd_mod = 0;
		psd->clhead = NULL;
		psd->cllast = &psd->clhead;
		psd->clvarhead = NULL;
		psd->clvarlast = &psd->clvarhead;
        pname->pn_psn = psd->pd_psn;
        pname->pn_flag = 0;
        pname->pn_dba = psd;
    }
    else
        psd = pname->pn_dba;
    if (stopper == ',')
    {
        if (!getsym(nxtnbc()))			// Collect msect name
        {
            errflag |= ERR_I;
            return;
        }
        else							// Collect rest of symbol if stopped
            persym();					//   here by a period
        if (isspace(stopper))
            stopper = nxtnbc();
        mname = (struct mn *)looksym(); // Look for it in the symbol table
        if (mname == NULL || mname->mn_type != SYT_MSC)
        {
            errflag |= ERR_I;
            return;
        }
        else
        {
            if (psd->pd_mdb != NULL)
            {
                if (psd->pd_mdb->md_nba != mname)
                {
                    errflag |= ERR_DN;
                    return;
                }
            }
            else
            {
                psd->pd_msn = mname->mn_msn;
                psd->pd_mdb = mname->mn_dba;
            }
        }
    }
    else								// No msect specified        
    {
        if (psd == NULL || psd->pd_mdb == NULL) // Already have an msect?
        {
            errflag |= ERR_I;			// No - error
            return;
        }
    }
    if (psd->pd_next == psd)			// Is this block linked yet?
    {
        if (pstail)						// No - link it now
            pstail->pd_next = psd;
        else
            pshead = psd;
        pstail = psd;
        psd->pd_next = NULL;
        while (stopper == ',')
            hndlatr(patrtbl, PASIZE, psd);
    }
    else
    {
        atrb = psd->pd_atrb;
        flag = psd->pd_flag;
        addr = psd->pd_address;
		mod = psd->pd_mod;
        while (stopper == ',')
            hndlatr(patrtbl, PASIZE, psd);
		if (mod != psd->pd_mod)
			psd->pd_mod = resolvemod(mod, psd->pd_mod);
        if (psd->pd_atrb != atrb || psd->pd_flag != flag ||
                psd->pd_address != addr)
        {
            errorc();
            psd->pd_atrb = atrb;
            psd->pd_flag = flag;
            psd->pd_address = addr;
        }
    }
    if (psd->pd_mdb->md_sdb == NULL)
        errflag |= ERR_I;				// Error if no msect for segment
    else
    {
        curpsd = psd;					// Store pointer to current psect
        curmsd = psd->pd_mdb;			// Store pointer to current msect
        cursgd = curmsd->md_sdb;		// Store pointer to current segment
        segatrb = cursgd->sd_atrb;		// Store current segment attributes
    }
    chkend(stopper);
}


//*****************************************************************
// Function: patrover - Process OVER attribute for .MSECT pseudo-op
// Returned: Nothing
//*****************************************************************

void patrover(
    struct pd *psd)

{
    psd->pd_atrb |= PA_OVER;
}


//*****************************************************************
// Function: patraddr - Process ADDR attribute for .MSECT pseudo-op
// Returned: Nothing
//*****************************************************************

void patraddr(
    struct pd *psd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFFFL)
            errorx();
        else
        {
            psd->pd_address = value;
            psd->pd_flag |= PF_ADDR;
        }
    }
}


//***************************************************************
// Function: patrmod - Process MOD attribute for .MSECT pseudo-op
// Returned: Nothing
//***************************************************************

void patrmod(
    struct pd *psd)

{
    ulong value;

    if (getaval(&value))
    {
        if (value == 0xFFFFFFFFL)
            errorx();
        else
            psd->pd_mod = value;

    }
}


//*************************************************
// Function: hndlatr - Process single attribute for
//				.SEG, .MSECT, or .PSECT
// Returned: Nothing
//*************************************************

void hndlatr(
    struct atributes *tbl,
    int    size,
    PD    *block)

{
    char  *cpnt;
    struct atributes *bpnt;
    int    cnt;
    char   chr;

    chr = nxtnbc();
    cpnt = symbuf.nsym;
    cnt = SYMMAXSZ;
    while (--cnt >= 0)
	*cpnt++ = ' ';						// Clear symbuf
    symsize = 0;						// Clear symbol size
    cpnt = symbuf.nsym;
    do
    {   if (symsize < 6)				// Is symbol full now?
	{
	    ++symsize;						// No
	    *cpnt++ = toupper(chr);			// Store character in symbol
	}
        else
        {
            errorq();
            return;
        }
		chr = nxtnbc();					// Get next character
    } while (chr && (chr != ',') && (chr != '='));
    stopper = chr;						// Store stopper
    if ((bpnt = (struct atributes *)srchtbl(symbuf.nsym, tbl, size, 6,
            sizeof(struct atributes))) == NULL)
        errorq();
    else
    {
        (*bpnt->at_func)(block);
        if (isspace(stopper))
            stopper = nxtnbc();
    }
}


//********************************************
// Function: getaval - Get value for attribute
// Returned: TRUE if OK, FALSE if error
//********************************************

static int getaval(
    ulong *value)

{
	VL val;

    if (stopper == '=')					// Does value follow?
    {
        getabs(&val);					// Yes - get it
        if (errflag & ERR_X)			// Error?
            return (FALSE);				// Yes
        else
        {
            *value = val.val;			// No
            return (TRUE);
        }
    }
    else
    {
        errorx();
        return (FALSE);
    }
}


//********************************************************
// Function: pentry - Process .ENTRY and .GLOBL pseudo-ops
// Returned: Nothing
//********************************************************

void pentry(void)

{
    SY *sym;

    do
    {   sym = getnxs();					// Collect symbol name
		if (sym->sy_flag & SYF_EXTERN)	// Is it external?
		{
			errflag |= ERR_A;			// Yes - error
			continue;
		}
		sym->sy_flag |= (SYF_ENTRY | SYF_USED);
        if ((sym->sy_flag & SYF_IMPORT) == 0) //Imported?
			sym->sy_flag |= SYF_INTERN; // No - make it internal
    } while (stopper == ',');
    chkend(stopper);
}


//**********************************************
// Function: pintern - Process .INTERN pseudo-op
// Returned: Nothing
//**********************************************

void pintern(void)

{
    entint(SYF_INTERN, ~0);
}


//**********************************************
// Function: pexport - Process .EXPORT pseudo-op
// Returned: Nothing
//**********************************************

void pexport(void)

{
    entint(SYF_EXPORT, ~SYF_INTERN);
}


//*********************************************************************
// Function: entint - Common to .ENTRY, .INTERN, and .EXPORT pseudo-ops
// Returned: Nothing
//*********************************************************************

void entint(
    int flags, int clear)

{
    SY *sym;

    do
    {   sym = getnxs();					// Collect symbol name
		if (sym->sy_flag & (SYF_EXTERN|SYF_IMPORT)) // Is it external or
        {					    		//   or imported?
			adrerr();					// Yes - error
            continue;
        }
///		else if (sym->sy_flag & SYF_UNDEF)// Undefined?
///			errflag |= ERR_U;			// Yes - error
		else
			sym->sy_flag |= flags;		// OK - set bits
        sym->sy_flag &= clear;
    } while (stopper == ',');
    chkend(stopper);
}


//**********************************************
// Function: pimport - Process .IMPORT pseudo-op
// Returned: Nothing
//**********************************************

void pimport(void)

{
    SY *sym;

    do
    {   sym = getnxs();					// Collect symbol name
		if (sym->sy_flag & SYF_IMPORT)	// Is it imported?
	    continue;						// Yes - nothing needed here
		else if (!(sym->sy_flag & (SYF_UNDEF|SYF_EXTERN)))
										// Undefined or external?
			adrerr();					// No - error
		else
		{
			sym->sy_flag |= (SYF_IMPORT); // OK - indicate imported
			sym->sy_flag &= ~(SYF_UNDEF|SYF_EXTERN); // Not undefined or
            sym->sy_val.val = 0;					 //   or external
            sym->sy_psect = 0;
		}
    } while (stopper == ',');
    chkend(stopper);
}


//**********************************************
// Function: pextern - Process .EXTERN pseudo-op
// Returned: Nothing
//**********************************************

void pextern(void)

{
    SY *sym;

    do
    {   sym = getnxs();					// Collect symbol name
		if (sym->sy_flag & (SYF_EXTERN|SYF_IMPORT)) // Is it an external or
						    			//   imported?
			continue;					// Yes - nothing needed here
		else if (!(sym->sy_flag & SYF_UNDEF))// Undefined?
			adrerr();					// No - error
		else
		{
			sym->sy_flag |= (SYF_EXTERN); // OK - indicate external
			sym->sy_flag &= ~SYF_UNDEF;	// Not undefined
            sym->sy_val.val = 0;
            sym->sy_psect = 0;
		}
    } while (stopper == ',');
    chkend(stopper);
}


//***********************************************************
// Function: getnxs - Get symbol name for .ENTRY, .INTERN and
//	.EXTERN pseudo-ops
// Returned: Address of symbol table entry for name
//***********************************************************

SY *getnxs(void)

{
    getsym(nxtnbc());					// Collect symbol
	if (gccflg)
		persym();
    stopper = nxtnb0(stopper);			// Make sure non-blank stopper
    return (findsym(FALSE));
}


//****************************************
// Function: podd - Process .ODD pseudo-op
// Returned: Nothing
//****************************************

void podd(void)

{
    if (!chkendx())
		return;
	domod(2, 1, 0x7FFFFFFF, 0);
}


//******************************************
// Function: peven - Process .EVEN pseudo-op
// Returned: Nothing
//******************************************

void peven(void)

{
    if (!chkendx())
		return;
	domod(2, 0, 0x7FFFFFFF, 0);
}


//****************************************
// Function: pmod - Process .MOD pseudo-op
// Returned: Nothing
//****************************************

void pmod(void)

{
	VL   val;

    getabs(&val);						// Get absolute value
    if (val.val == 0)					// Must not be 0
    {
        errorx();
		skiprest();
		return;
    }
    if (!chkend(stopper))				// Must have end next
		return;
	domod(val.val, 0, 0x7FFFFFFF, 0);
}


//************************************************
// Function: pp2align - Process .P2ALIGN pseudo-op
// Returned: Nohting
//************************************************

// This pseudo-op is generated by GCC. It specifies the modulus as a
//   power of 2
// Format:
//		.P2ALIGN	mod, fill, max
//   Where:
//		mod  = (required) Modulus (as a power of 2)
//		fill = (optional) Fill value (default is 0x90 (NOP))
//		max  = (optional) Maximum number of bytes to skip - if more would be
//				 skipped none are skipped!

void pp2align(void)

{
	VL   val;
	int  mod;
	int  fill;
	int  limit;

	fill = 0x90;
	limit = 0x7FFFFFFF;
    getabs(&val);						// Get power of two
	if (errflag != 0)
		return;
	mod = val.val;
	if (stopper == ',')
	{
		if ((stopper = nxtnbc()) != ',' && !eolflg)
		{
			hldchar = stopper;
			getabs(&val);					// Get fill value
			fill = val.val;
		}
		if (stopper == ',')
		{
			getabs(&val);				// Get limit value if have one
			limit = val.val;
		}
	}
    if (!chkend(stopper))				// Must have end next
		return;

///	printf("### pwr=%d fill=%02.2X limit=%d\n", mod, (uchar)fill, limit);

	domod(1 << mod, 0, limit, fill);
}


//***************************************************
// Function: domod - Do the work for pseudo-ops which
//				specify the modulus for the offset
// Returned: Nothing
//***************************************************

static void domod(
	int mod,
	int offset,
	int limit,
	int fill)

{
	CL  *clp;
	long rem;
	long amnt;

    if (curpsd != NULL)
    {
		curpsd->pd_mod = (curpsd->pd_mod == 0) ? mod :
				resolvemod(mod, curpsd->pd_mod);
		amnt = curpsd->pd_ofs - offset;
		if ((rem = amnt % mod) != 0)
			amnt += (mod - rem);
		amnt += offset;
		clp = clget(CL_MOD_SZ);
		clp->type = CLT_MOD;
		clp->size = amnt - curpsd->pd_ofs;
		clp->mval = mod;
		clp->mofs = offset;
		clp->fill = fill;
		clp->limit = limit;
		clinsert(clp);
	}
}


//******************************************
// Function: pbyte - Process .BYTE pseudo-op
// Returned: Nothing
//******************************************

void pexpb(void)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    do
    {
		exprsn(&val);					// Get value
		clp = clget(CL_DATA_SZ);
		clp->type = CLT_DATA;
		clp->size = 1;
		storevalue(&clp->vald, VALUE_1_U, &val, xstrbufr);
		clinsert(clp);
    } while (stopper == ',');			// Continue if more
    chkend(stopper);
}


//***************************************************
// Function: pexpw - Process .EXPW or .WORD pseudo-op
// Returned: Nothing
//***************************************************

void pexpw(void)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    do
    {
		exprsn(&val);					// Get value
		clp = clget(CL_DATA_SZ);
		clp->type = CLT_DATA;
		clp->size = 2;
		storevalue(&clp->vald, VALUE_2_U, &val, xstrbufr);
		clinsert(clp);
    } while (stopper == ',');			// Continue if more
    chkend(stopper);
}


//***************************************************
// Function: pexpl - Process .EXPL or .LONG pseudo-op
// Returned: Nothing
//***************************************************

void pexpl(void)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    do
    {
		exprsn(&val);					// Get value
		clp = clget(CL_DATA_SZ);
		clp->type = CLT_DATA;
		clp->size = 4;
		storevalue(&clp->vald, VALUE_4_U, &val, xstrbufr);
		clinsert(clp);
    } while (stopper == ',');			// Continue if more
    chkend(stopper);
}


//******************************************
// Function: pquad - Process .QUAD pseudo-op
// Returned: Nothing
//******************************************

// WARNING: The high 32 bits are always 0!!

void pquad(void)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    do
    {
		exprsn(&val);					// Get value
		clp = clget(CL_DATA_SZ);
		clp->type = CLT_DATA;
		clp->size = 8;
		storevalue(&clp->vald, VALUE_8, &val, xstrbufr);
		clinsert(clp);
    } while (stopper == ',');			// Continue if more
    chkend(stopper);
}


//********************************************
// Function: paddrw - Process .ADDRW pseudo-op
// Returned: Nothing
//********************************************

void paddrw(void)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    do
    {
		exprsn(&val);					// Get value
		clp = clget(CL_DATA_SZ);
		clp->type = CLT_DATA;
		clp->size = 4;
		storevalue(&clp->vald, VALUE_2_A, &val, xstrbufr);
		clp->vald.value.flags |= VLF_FAR;
		clinsert(clp);
    } while (stopper == ',');			// Continue if more
    chkend(stopper);
}


//********************************************
// Function: paddrl - Process .ADDRL pseudo-op
// Returned: Nothing
//********************************************

void paddrl(void)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    do
    {
		exprsn(&val);					// Get value
		clp = clget(CL_DATA_SZ);
		clp->type = CLT_DATA;
		clp->size = 6;
		storevalue(&clp->vald, VALUE_4_A, &val, xstrbufr);
		clp->vald.value.flags |= VLF_FAR;
		clinsert(clp);
    } while (stopper == ',');			// Continue if more
    chkend(stopper);
}


//********************************************
// Function: plcomm - Process .LCOMM pseudo-op
// Returned: Nothing
//********************************************

// This pseudo-op is generated by GCC to declare a "local common" block.
//   Its format is:
//		.LCOMM	symbol, len, mod
//   Where:
//		symbol = (required) Symbol name
//		len    = (required) Length of common block
//		mod    = (optional) Modulus for start of common block, defaults to
//							  the the lesser of the len value and 8 if not
//							  specified.
// Since we don't really support anything like a "local common" block, we
//   fake this up by invoking the following built-in macro;
//		.PSECT	_BSS_p, DGROUP_m, mod=4
//		.MOD	mod
//	symbol:
//		.BLKB	len
//		.PSECT	prevpsect

void plcomm(void)

{
	static IC   icb = {NULL, NULL, NULL, NULL, 0, 0, 0, ICT_STATIC, 0};
	static char bufr[300];

	VL    val;
    PN   *pname;
	char *pnt;
	int   mod;
	int   len;

	memcpy(symbuf.nsym, "_BSS_p", 6);	// See if the .BSS psect is defined
	memset(symbuf.nsym + 6, ' ', SYMMAXSZ - 8);
    pname = (struct pn *)looksym();		// Look for it in the symbol table

    if (ptype == 0)
        ptype = P_80386;
    if (!getsym(nxtnbc()))				// Collect symbol name
    {
        errflag |= ERR_Q;
        return;
    }
    persym();							// Collect rest of symbol if stopped
										//   here by a period
    if (isspace(stopper))
        stopper = nxtnbc();
	if (stopper != ',')
    {
        errflag |= ERR_Q;
        return;
    }
	getabs(&val);
	if (errflag != 0)
		return;
	len = val.val;
	if (stopper == ',')
	{
		getabs(&val);
		if (errflag != 0)
			return;
		mod = val.val;
	}
	else
		mod = (len < 8) ? len : 8;
	if (!chkend(stopper))
		return;	

	// Here when ready to invoke the built-in macro

	pnt = bufr + sprintf(bufr, "%s\n\t.MOD\t%d\n%.*s:\n\t.BLKB\t%d\n"CCSTR_EST,
			(pname != NULL && (pname->pn_flag & SYF_UNDEF) == 0) ?
			"\t.PSECT\t_BSS_p" : "\t.MSECT\tDGROUP_m,DGROUP_s,read,write\n"
			"\t.PSECT\t_BSS_p,DGROUP_m,mod=4", len, symsize, symbuf.nsym, len);
	if (curpsd != NULL)
		sprintf(pnt - 1, "\t.PSECT\t%.*s\n"CCSTR_EST, SYMMAXSZ,
				curpsd->pd_nba->pn_name);
	if (!havesection)					// Set up the segments if necessary
		firstsection();
	icb.ic_cbc = 301;
	icb.ic_link = inspnt;
	icb.ic_cbp = bufr;
	inspnt = &icb;
	eolflg = TRUE;
}


//**************************************************************
// Function: pblkb - Process .BLKB, .SKIP, and .SPACE pseudo-ops
// Returned: Nothing
//**************************************************************

void pblkb(void)

{
    doblk(1);
}


//******************************************
// Function: pblkw - Process .BLKW pseudo-op
// Returned: Nothing
//******************************************

void pblkw(void)

{
    doblk(2);
}


//******************************************
// Function: pblkl - Process .BLKL pseudo-op
// Returned: Nothing
//******************************************

void pblkl(void)

{
    doblk(4);
}


//**************************************************
// Function: doblk - Common to all .BLK.s pseudo-ops
// Returned: Nothing
//**************************************************

void doblk(
    int size)

{
	VL  val;
	CL *clp;

    chkpsect();							// Make sure have psect specified
    exprsn(&val);						// Get value of expression
    if (val.kind != VLK_ABS || (errflag&ERR_U) || val.val < 0)
	{									// Value must be absolute, positive
		errflag |= ERR_V;				//   and defined, else V error
		val.kind = VLK_ABS;
		val.psect = 0;
		val.val = 0;
    }
	clp = clget(CL_CODE_SZ);
	clp->type = CLT_BLK;
	clp->size = val.val * size;
	clinsert(clp);
    chkend(stopper);
} 


//********************************************
// Function: pasciz - Process .ASCIZ pseudo-op
// Returned: Nothing
//********************************************

void pasciz(void)

{
    chrstring(dirchr, TRUE);
}


//********************************************
// Function: pascii - Process .ASCII pseudo-op
// Returned: Nothing
//********************************************

void pascii()

{
    chrstring(dirchr, FALSE);
}


//********************************************
// Function: pascii - Process .ASCIU pseudo-op
// Returned: Nothing
//********************************************

void pasciu(void)

{
    chrstring(upperchr, FALSE);
}


//********************************************
// Function: pascii - Process .ASCIL pseudo-op
// Returned: Nothing
//********************************************

void pascil(void)

{
    chrstring(lowerchr, FALSE);
}


//*************************************************************************
// Function: chrstring - Do the work for .ASCII, .ASCIZ, .ASCIU, and .ASCIL
// Returned: Nothing
//*************************************************************************

static void chrstring(
    void (*func)(int c, char *pnt),
	int    addnull)

{
	VL    val;
	CL   *clp;
	char *pnt;
	int   cnt;
    char  chr;
    char  delim;
	uchar neednull;
	char  bufr[ASCIIMAX + 4];

    chkpsect();							// Make sure have psect specified
    while ((chr=nxtnbc()) != ';' && !eolflg)
    {
		if (chr == '{')					// If value
		{
			do
			{
				exprsn(&val);
				clp = clget(CL_CODE_SZ);
				clp->type = CLT_DATA;
				storevalue(&clp->vald, VALUE_1_U, &val, xstrbufr);
				clp->size = 1;
				clinsert(clp);
			} while (stopper == ',');
			if (stopper != '}')
			{
				queerr();
				return;
			}
			if (addnull)
			{
			 	if ((chr = nxtnbc()) == ';' || eolflg)
				{
					clp = clget(CL_ASCII_SZ + 1);
					clp->type = CLT_ASCII;
					clp->size = 1;
					clp->adata[0] = 0;
					clinsert(clp);
				}
				if (!eolflg)
					hldchar = chr;
			}
		}
		else							// If character string
		{
			delim = chr;
			pnt = bufr;
			cnt = 0;
			while ((chr=nxtchar()) != delim)
			{
				if(eolflg)
				{
					queerr();
					return;
				}
				if (chr == '\\')		// Prefix characater?
				{
					chr = nxtchar();
					if(eolflg)
					{
						queerr();
						return;
					}
					if (isdigit(chr))
						chr = getvalue(chr, 8);
					else
					{
						switch (chr)
						{
						 case 'b':			// Backspace (BS)
							chr = '\b';
							break;

						 case 'f':			// Formfeed (FF)
							chr = '\f';
							break;

						 case 'n':			// Newline (LF)
							chr = '\n';
							break;

						 case 'r':			// Carriage-return (CF)
							chr = '\r';
							break;

						 case 't':			// Horizontal tab (HT)
							chr = '\t';
							break;

						 case 'x':			// Hex value
							chr = getvalue(nxtchar(), 16);
							break;
						}
					}
				}
				if (cnt <= ASCIIMAX)
				{
					cnt++;
					func(chr, pnt++);
				}
			}
			if (addnull)
			{
			 	neednull = ((chr = nxtnbc()) == ';' || eolflg);
				if (!eolflg)
					hldchar = chr;
			}
			else
				neednull = FALSE;
			clp = clget(CL_ASCII_SZ + cnt + neednull);
			clp->type = CLT_ASCII;
			clp->size = cnt + neednull;
			memcpy(clp->adata, bufr, cnt);
			if (addnull)
				clp->adata[cnt] = 0;
			clinsert(clp);
		}
    }
    stopper = nxtnb0(chr);
}


static int getvalue(
	int chr,
	int radix)

{
	int value;
	int cval;

	value = 0;
	while (isxdigit(chr))
	{
		cval = chr;
		if (cval > '9')
			cval += 9;
		cval &= 0x0F;
		if (cval >= radix)
			break;
		value = value * radix + cval;
		chr = nxtchar();
	}
	hldchar = chr;
	return (value);
}


//********************************************
// Function: dirchr - Store character directly
// Returned: Nothing
//********************************************

static void dirchr(
    int   chr,
	char *pnt)

{
    *pnt = chr;
}


//**********************************************************
// Function: upperchr - Store character forced to upper case
// Returned: Nothing
//**********************************************************

static void upperchr(
    int   chr,
	char *pnt)

{
    *pnt = toupper(chr);
}


//**********************************************************
// Function: upperchr - Store character forced to lower case
// Returned: Nothing
//**********************************************************

static void lowerchr(
    int   chr,
	char *pnt)

{
    *pnt = tolower(chr);
}


//********************************************
// Function: pstype - Process .STYPE pseudo-op
// Returned: Nothing
//********************************************

// Format is:
//	.STYPE	sym1,sym2
//   The value of sym1 is set as follows
//   based on the attributes of sym2
//	2000 = Exported sumbol
//	1000 = Imported symbol
//	0800 = Macro name
//	0400 = Local symbol
//	0200 = Relocatable symbol
//	0100 = External symbol
//	0080 = Defined symbol
//	0040 = Multiply defined symbol
//	0020 = Label
//	0010 = Suppressed symbol
//	0008 = Internal symbol
//	0004 = Entry symbol
//	0002 = Used symbol
//	0001 = Byte symbol

void pstype(void)

{
    SY  *sym1;
	SY  *sym2;
    int  temp;

    if ((sym1=nchsty()) == NULL)		// Setup first symbol
		return;
    if (!getsym(nxtnbc()))				// Collect second symbol
    {
		queerr();
		return;
    }
    if (symbuf.nsym[0] == 0)			// Local symbol?
		sym1->sy_val.val = 0x0400;		// Yes
    else if (symbuf.nsym[0] |= 0x80, looksym())// Macro name?
		sym1->sy_val.val = 0x0800;		// Yes
    else
		sym1->sy_val.val = 0x0000;
    symbuf.nsym[0] &= ~0x80;
    if ((sym2 = looksym()) != NULL)		// Look for symbol in symbol table
    {
		if (sym2->sy_flag & SYF_IMPORT)	// Imported?
			sym1->sy_val.val |= 0x1000;	// Yes
		else if (sym2->sy_flag & SYF_EXTERN) // External?
			sym1->sy_val.val |= 0x0100;	// Yes
		else if (sym2->sy_flag & SYF_EXTERN) // Relocatable?
			sym1->sy_val.val |= 0x0200;	// Yes
		temp = sym2->sy_flag ^ SYF_UNDEF; // Get flag bits with undefined bit
										//   inverted
		sym1->sy_val.val |= (long)(temp & 0xFF);
    }
    if (prmcnt <= 0)
		sym1->sy_flag |= SYF_USED;

///// GENERATE LSTVAL ELEMENT HERE

    chkend(stopper);
}


//********************************************
// Function: pnchar - Process .NCHAR pseudo-op
// Returned: Nothing
//********************************************

// Format is:
//	.NCHAR	sym,<str>
//   The value of sym is set to the
//   number of characters in str

void pnchar(void)

{
    SY  *sym;
    char chr;

    if ((sym=nchsty()) == NULL)			// Setup first symbol
		return;
    chr = nxtnbc();
    if (chr != '{')
    {
		queerr();
		return;
    }
    sym->sy_val.val = -1;
    do									// Scan to matching right angle
    {   ++sym->sy_val.val;
        chr = nxtchar();
    } while (!eolflg && chr != '}');
    if (eolflg)
    {
		queerr ();
		return;
    }
    if (prmcnt <= 0)
		sym->sy_flag |= SYF_USED;

///// GENERATE LSTVAL ELEMENT HERE

    chkend(stopper);
}


//*********************************************************
// Function: nchsty - Do common setup for .STYPE and .NCHAR
// Returned: Address of symbol table entry
//*********************************************************

SY *nchsty(void)

{
    SY *sym;

    if (!getsym(nxtnbc()) || stopper != ',') // Collect symbol to be defined
    {
		queerr();
		return (NULL);
    }
    sym = findsym(TRUE);				// Find it in the symbol table
    if (sym->sy_flag & (SYF_LABEL|SYF_EXTERN|SYF_IMPORT))
    {									// Error if external or label
		errflag |= ERR_M;
		skiprest();
		return (NULL);
    }
    sym->sy_flag &= ~SYF_UNDEF;			// Indicate defined and absolute
    sym->sy_flag |= SYF_ABS;
    sym->sy_psect = 0;
    return (sym);
}


//**********************************************
// Function: pnrname - Process .NRNAME pseudo-op
// Returned: Nothing
//**********************************************

void pnrname(void)

{
    if (chkendx ())
		prnflg = FALSE;
}


//**********************************************
// Function: pprname - Process .PRNAME pseudo-op
// Returned: Nothing
//**********************************************

void pprname(void)

{
    if (chkendx ())
		prnflg = TRUE;
}


//********************************************
// Function: pstart - Process .START pseudo-op
// Returned: Nothing
//********************************************

void pstart(void)

{
    if (strclp != NULL)					// Can only have one!
    {
        errflag |= ERR_D;
        return;
    }
    exprsn(&strval);					// Get starting address
	strncpy(strexp, xstrbufr, SPCEXPSZ - 1);
	chkend(stopper);	
	strclp = clget(CL_DUMMY_SZ);
	strclp->type = CLT_DUMMY;
	clinsert(strclp);
}


//********************************************
// Function: pstack - Process .STACK pseudo-op
// Returned: Nothing
//********************************************

void pstack(void)

{
    if (stkclp != NULL)					// Can only have one!
    {
        errflag |= ERR_D;
        return;
    }
    exprsn(&stkval);					// Get starting address
	strncpy(stkexp, xstrbufr, SPCEXPSZ - 1);
	chkend(stopper);	
	stkclp = clget(CL_DUMMY_SZ);
	stkclp->type = CLT_DUMMY;
	clinsert(stkclp);
}


//********************************************
// Function: pstk16 - Process .STK16 pseudo-op
// Returned: Nothing
//********************************************

void pstk16(void)

{
    if (chkendx())
        stack32 = FALSE;
}


//********************************************
// Function: pstk32 - Process .STK32 pseudo-op
// Returned: Nothing
//********************************************

void pstk32(void)

{
    if (chkendx())
        stack32 = TRUE;
}


//********************************************
// Function: pdebug - Process .DEBUG pseudo-op
// Returned: Nothing
//********************************************

void pdebug(void)

{
    if (dbgclp != NULL)					// Can only have one!
    {
        errflag |= ERR_D;
        return;
    }
    exprsn(&dbgval);					// Get starting address
	strncpy(dbgexp, xstrbufr, SPCEXPSZ - 1);
	chkend(stopper);	
	dbgclp = clget(CL_DUMMY_SZ);
	dbgclp->type = CLT_DUMMY;
	clinsert(dbgclp);
}
